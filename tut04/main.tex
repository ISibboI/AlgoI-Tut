\documentclass[ngerman,hyperref={pdfpagelabels=false}]{beamer}

% -----------------------------------------------------------------------------

\graphicspath{{images/}}

% -----------------------------------------------------------------------------

\usetheme{KIT}

\setbeamercovered{transparent}
%\setbeamertemplate{enumerate items}[ball]

\newenvironment<>{KITtestblock}[2][]
{\begin{KITcolblock}<#1>{#2}{KITblack15}{KITblack50}}
{\end{KITcolblock}}

\usepackage[ngerman,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[TS1,T1]{fontenc}
\usepackage{array}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{beamerKITdefs}

\pdfpageattr {/Group << /S /Transparency /I true /CS /DeviceRGB>>}	%required to prevent color shifting withd transparent images


\title{Algorithmen I - Tutorium 4}
\subtitle{Sebastian Schmidt -- \textit{isibboi@gmail.com}}

\author[Sebastian Schmidt]{Sebastian Schmidt}
\institute{Arbeitsgruppe Kryptographie und Sicherheit}

\TitleImage[width=\titleimagewd,height=\titleimageht]{titel}

\KITinstitute{Arbeitsgruppe Kryptographie und Sicherheit}
\KITfaculty{Fakult\"at f\"ur Informatik}

% -----------------------------------------------------------------------------

\begin{document}
\setlength\textheight{7cm} %required for correct vertical alignment, if [t] is not used as documentclass parameter


% title frame
\begin{frame}
  \maketitle
\end{frame}

\begin{frame}{Wahrscheinlichkeitstheorie}
\includegraphics[width=\textwidth]{WT}
\end{frame}

\begin{frame}{Hashing mit einfach verketteten Listen}
\begin{itemize}[<+->]
\item Hashtabelle mit $h_n(x) := x \mod n$
\begin{itemize}
\item Wie groß sollte die Hashtabelle sein?
\item Gegeben $\{36, 78, 50, 1, 92, 15, 43, 99, 64\}$. Füge diese Zahlen in eine Hashtabelle mit Hashfunktion $h_5$ und $h_7$ ein.
\end{itemize}
\item Gebt Beispiele für gute und schlechte Hashfunktionen
\item Laufzeiten: \texttt{insert}, \texttt{find} und \texttt{remove}
\end{itemize}
\end{frame}

\begin{frame}{Anwendungsbeispiele für Hashtabellen}
Hashtabellen sind besser als Bäume, wenn man die erwartete Laufzeit betrachtet.
\begin{itemize}
\item<2-> Fallen euch konkrete Beispiele oder Gegenbeispiele ein?
\end{itemize}
\end{frame}

\begin{frame}{Beweis über Worst-Case}
Seien $m, n \in \mathbb{N}$.
$n$ ist die Anzahl der Elemente, die in eine Hashtabelle der Größe $m$ eingefügt werden.

Sei $U$ ein Universum mit $|U| \geq mn$.

Zeige, dass eine Teilmenge $M \subset U$ existiert mit $|M| \geq n$, sodass alle Elemente aus $M$ dem selben Slot der Hashtabelle zugeordnet werden.
\end{frame}

\begin{frame}{Verbesserung des Worst-Case}
\textit{\glqq Nach dem dritten Glas Bier behauptet ein Kommilitone, man könne Hashing mit verketteten Listen entscheidend verbessern, indem man die verketteten Listen stets sortiert halte.\grqq}

\begin{itemize}[<+->]
\item Wie ändert sich dadurch die Worst-Case Laufzeit von \texttt{insert}, \texttt{find} und \texttt{remove}?
\item Was muss man tun, um die Sortiertheit auszunutzen?
\item Wie ändert sich nun die Laufzeit?
\item Kann man durch Amortisierung noch was verbessern?
\end{itemize}
\end{frame}

\begin{frame}{Sparse Array}
Ein Sparse Array ist eine Datenstruktur mit den Eigenschaften eines beschränkten Arrays und zusätzlich:
\begin{itemize}
\item Die Erzeugung eines leeren Sparse Arrays mit $n$ Slots braucht $O(1)$ Zeit
\item Es gibt eine Operation \texttt{reset}, die das Array in $O(1)$ Zeit leert
\item Das Sparse Array unterstützt \texttt{get(i)} und \texttt{set(i, x)} in $O(1)$ Zeit
\begin{itemize}
\item \texttt{get(i)}: Gibt das Element im Slot $i$ zurück, oder $\perp$, wenn der Slot leer ist
\item \texttt{set(i, x)}: Speichert $x$ im Slot $i$
\end{itemize}
\end{itemize}

Wir können beliebig viel uninitialisierten Speicher in $O(1)$ Zeit allokieren.

Ein Sparse Array mit $n$ Slots braucht $O(n)$ Speicher.
\end{frame}

\begin{frame}{Sparse Array}
\begin{itemize}[<+->]
\item Geht unsere Realisierung für große Datentypen sparsam mit dem Speicher um? Wenn nein, kann man sie noch verbessern?
\item Welche Vor- und Nachteile im Bezug auf das Iterieren und den Speicherverbrauch hat das Sparse Array gegenüber beschränkten Arrays?
\end{itemize}
\end{frame}

\begin{frame}{Ende!}
\centering
\includegraphics[width=0.5\textwidth]{encryptic}
\end{frame}


\end{document}
